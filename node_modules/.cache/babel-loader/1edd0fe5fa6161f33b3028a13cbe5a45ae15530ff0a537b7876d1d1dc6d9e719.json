{"ast":null,"code":"// Get paginated data slice\nexport const getPaginatedData = (items, pagination) => {\n  const startIndex = (pagination.currentPage - 1) * pagination.pageSize;\n  const endIndex = startIndex + pagination.pageSize;\n  return items.slice(startIndex, endIndex);\n};\n\n// Calculate total pages\nexport const getTotalPages = (totalItems, pageSize) => {\n  return Math.ceil(totalItems / pageSize);\n};\n\n// Get pagination info text\nexport const getPaginationInfo = pagination => {\n  const startItem = (pagination.currentPage - 1) * pagination.pageSize + 1;\n  const endItem = Math.min(pagination.currentPage * pagination.pageSize, pagination.totalItems);\n  if (pagination.totalItems === 0) {\n    return 'Нет данных для отображения';\n  }\n  return `Показано ${startItem}-${endItem} из ${pagination.totalItems} записей`;\n};\n\n// Check if we can go to previous page\nexport const canGoPrevious = currentPage => {\n  return currentPage > 1;\n};\n\n// Check if we can go to next page\nexport const canGoNext = (currentPage, totalPages) => {\n  return currentPage < totalPages;\n};\n\n// Get page numbers for pagination controls\nexport const getPageNumbers = (currentPage, totalPages) => {\n  const delta = 2; // Number of pages to show on each side\n  const range = [];\n  for (let i = Math.max(2, currentPage - delta); i <= Math.min(totalPages - 1, currentPage + delta); i++) {\n    range.push(i);\n  }\n  if (currentPage - delta > 2) {\n    range.unshift(-1); // -1 represents ellipsis\n  }\n  if (currentPage + delta < totalPages - 1) {\n    range.push(-1); // -1 represents ellipsis\n  }\n  range.unshift(1); // Always show first page\n  if (totalPages > 1) {\n    range.push(totalPages); // Always show last page\n  }\n  return range.filter((page, index, array) => array.indexOf(page) === index);\n};\n\n// Update pagination state when data changes\nexport const updatePaginationForNewData = (currentPagination, newTotalItems) => {\n  const totalPages = getTotalPages(newTotalItems, currentPagination.pageSize);\n  return {\n    ...currentPagination,\n    totalItems: newTotalItems,\n    currentPage: Math.min(currentPagination.currentPage, Math.max(1, totalPages))\n  };\n};\n\n// Reset pagination to first page\nexport const resetPagination = pageSize => ({\n  currentPage: 1,\n  pageSize,\n  totalItems: 0\n});","map":{"version":3,"names":["getPaginatedData","items","pagination","startIndex","currentPage","pageSize","endIndex","slice","getTotalPages","totalItems","Math","ceil","getPaginationInfo","startItem","endItem","min","canGoPrevious","canGoNext","totalPages","getPageNumbers","delta","range","i","max","push","unshift","filter","page","index","array","indexOf","updatePaginationForNewData","currentPagination","newTotalItems","resetPagination"],"sources":["D:/work/komus/3pl-site/src/features/inventory-table/lib/paginationUtils.ts"],"sourcesContent":["import { PlacedItemDto, PaginationState } from '../model/types';\r\n\r\n// Get paginated data slice\r\nexport const getPaginatedData = (\r\n  items: PlacedItemDto[],\r\n  pagination: PaginationState\r\n): PlacedItemDto[] => {\r\n  const startIndex = (pagination.currentPage - 1) * pagination.pageSize;\r\n  const endIndex = startIndex + pagination.pageSize;\r\n  return items.slice(startIndex, endIndex);\r\n};\r\n\r\n// Calculate total pages\r\nexport const getTotalPages = (totalItems: number, pageSize: number): number => {\r\n  return Math.ceil(totalItems / pageSize);\r\n};\r\n\r\n// Get pagination info text\r\nexport const getPaginationInfo = (pagination: PaginationState): string => {\r\n  const startItem = (pagination.currentPage - 1) * pagination.pageSize + 1;\r\n  const endItem = Math.min(pagination.currentPage * pagination.pageSize, pagination.totalItems);\r\n  \r\n  if (pagination.totalItems === 0) {\r\n    return 'Нет данных для отображения';\r\n  }\r\n  \r\n  return `Показано ${startItem}-${endItem} из ${pagination.totalItems} записей`;\r\n};\r\n\r\n// Check if we can go to previous page\r\nexport const canGoPrevious = (currentPage: number): boolean => {\r\n  return currentPage > 1;\r\n};\r\n\r\n// Check if we can go to next page\r\nexport const canGoNext = (currentPage: number, totalPages: number): boolean => {\r\n  return currentPage < totalPages;\r\n};\r\n\r\n// Get page numbers for pagination controls\r\nexport const getPageNumbers = (currentPage: number, totalPages: number): number[] => {\r\n  const delta = 2; // Number of pages to show on each side\r\n  const range: number[] = [];\r\n  \r\n  for (let i = Math.max(2, currentPage - delta); \r\n       i <= Math.min(totalPages - 1, currentPage + delta); \r\n       i++) {\r\n    range.push(i);\r\n  }\r\n  \r\n  if (currentPage - delta > 2) {\r\n    range.unshift(-1); // -1 represents ellipsis\r\n  }\r\n  if (currentPage + delta < totalPages - 1) {\r\n    range.push(-1); // -1 represents ellipsis\r\n  }\r\n  \r\n  range.unshift(1); // Always show first page\r\n  if (totalPages > 1) {\r\n    range.push(totalPages); // Always show last page\r\n  }\r\n  \r\n  return range.filter((page, index, array) => array.indexOf(page) === index);\r\n};\r\n\r\n// Update pagination state when data changes\r\nexport const updatePaginationForNewData = (\r\n  currentPagination: PaginationState,\r\n  newTotalItems: number\r\n): PaginationState => {\r\n  const totalPages = getTotalPages(newTotalItems, currentPagination.pageSize);\r\n  \r\n  return {\r\n    ...currentPagination,\r\n    totalItems: newTotalItems,\r\n    currentPage: Math.min(currentPagination.currentPage, Math.max(1, totalPages)),\r\n  };\r\n};\r\n\r\n// Reset pagination to first page\r\nexport const resetPagination = (pageSize: number): PaginationState => ({\r\n  currentPage: 1,\r\n  pageSize,\r\n  totalItems: 0,\r\n}); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}