{"ast":null,"code":"import _objectSpread from\"D:/work/komus/3pl-site/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Get paginated data slice\nexport const getPaginatedData=(items,pagination)=>{const startIndex=(pagination.currentPage-1)*pagination.pageSize;const endIndex=startIndex+pagination.pageSize;return items.slice(startIndex,endIndex);};// Calculate total pages\nexport const getTotalPages=(totalItems,pageSize)=>{return Math.ceil(totalItems/pageSize);};// Get pagination info text\nexport const getPaginationInfo=pagination=>{const startItem=(pagination.currentPage-1)*pagination.pageSize+1;const endItem=Math.min(pagination.currentPage*pagination.pageSize,pagination.totalItems);if(pagination.totalItems===0){return'Нет данных для отображения';}return\"\\u041F\\u043E\\u043A\\u0430\\u0437\\u0430\\u043D\\u043E \".concat(startItem,\"-\").concat(endItem,\" \\u0438\\u0437 \").concat(pagination.totalItems,\" \\u0437\\u0430\\u043F\\u0438\\u0441\\u0435\\u0439\");};// Check if we can go to previous page\nexport const canGoPrevious=currentPage=>{return currentPage>1;};// Check if we can go to next page\nexport const canGoNext=(currentPage,totalPages)=>{return currentPage<totalPages;};// Get page numbers for pagination controls\nexport const getPageNumbers=(currentPage,totalPages)=>{const delta=2;// Number of pages to show on each side\nconst range=[];for(let i=Math.max(2,currentPage-delta);i<=Math.min(totalPages-1,currentPage+delta);i++){range.push(i);}if(currentPage-delta>2){range.unshift(-1);// -1 represents ellipsis\n}if(currentPage+delta<totalPages-1){range.push(-1);// -1 represents ellipsis\n}range.unshift(1);// Always show first page\nif(totalPages>1){range.push(totalPages);// Always show last page\n}return range.filter((page,index,array)=>array.indexOf(page)===index);};// Update pagination state when data changes\nexport const updatePaginationForNewData=(currentPagination,newTotalItems)=>{const totalPages=getTotalPages(newTotalItems,currentPagination.pageSize);return _objectSpread(_objectSpread({},currentPagination),{},{totalItems:newTotalItems,currentPage:Math.min(currentPagination.currentPage,Math.max(1,totalPages))});};// Reset pagination to first page\nexport const resetPagination=pageSize=>({currentPage:1,pageSize,totalItems:0});","map":{"version":3,"names":["getPaginatedData","items","pagination","startIndex","currentPage","pageSize","endIndex","slice","getTotalPages","totalItems","Math","ceil","getPaginationInfo","startItem","endItem","min","concat","canGoPrevious","canGoNext","totalPages","getPageNumbers","delta","range","i","max","push","unshift","filter","page","index","array","indexOf","updatePaginationForNewData","currentPagination","newTotalItems","_objectSpread","resetPagination"],"sources":["D:/work/komus/3pl-site/src/features/inventory-table/lib/paginationUtils.ts"],"sourcesContent":["import { PlacedItemDto, PaginationState } from '../model/types';\r\n\r\n// Get paginated data slice\r\nexport const getPaginatedData = (\r\n  items: PlacedItemDto[],\r\n  pagination: PaginationState\r\n): PlacedItemDto[] => {\r\n  const startIndex = (pagination.currentPage - 1) * pagination.pageSize;\r\n  const endIndex = startIndex + pagination.pageSize;\r\n  return items.slice(startIndex, endIndex);\r\n};\r\n\r\n// Calculate total pages\r\nexport const getTotalPages = (totalItems: number, pageSize: number): number => {\r\n  return Math.ceil(totalItems / pageSize);\r\n};\r\n\r\n// Get pagination info text\r\nexport const getPaginationInfo = (pagination: PaginationState): string => {\r\n  const startItem = (pagination.currentPage - 1) * pagination.pageSize + 1;\r\n  const endItem = Math.min(pagination.currentPage * pagination.pageSize, pagination.totalItems);\r\n  \r\n  if (pagination.totalItems === 0) {\r\n    return 'Нет данных для отображения';\r\n  }\r\n  \r\n  return `Показано ${startItem}-${endItem} из ${pagination.totalItems} записей`;\r\n};\r\n\r\n// Check if we can go to previous page\r\nexport const canGoPrevious = (currentPage: number): boolean => {\r\n  return currentPage > 1;\r\n};\r\n\r\n// Check if we can go to next page\r\nexport const canGoNext = (currentPage: number, totalPages: number): boolean => {\r\n  return currentPage < totalPages;\r\n};\r\n\r\n// Get page numbers for pagination controls\r\nexport const getPageNumbers = (currentPage: number, totalPages: number): number[] => {\r\n  const delta = 2; // Number of pages to show on each side\r\n  const range: number[] = [];\r\n  \r\n  for (let i = Math.max(2, currentPage - delta); \r\n       i <= Math.min(totalPages - 1, currentPage + delta); \r\n       i++) {\r\n    range.push(i);\r\n  }\r\n  \r\n  if (currentPage - delta > 2) {\r\n    range.unshift(-1); // -1 represents ellipsis\r\n  }\r\n  if (currentPage + delta < totalPages - 1) {\r\n    range.push(-1); // -1 represents ellipsis\r\n  }\r\n  \r\n  range.unshift(1); // Always show first page\r\n  if (totalPages > 1) {\r\n    range.push(totalPages); // Always show last page\r\n  }\r\n  \r\n  return range.filter((page, index, array) => array.indexOf(page) === index);\r\n};\r\n\r\n// Update pagination state when data changes\r\nexport const updatePaginationForNewData = (\r\n  currentPagination: PaginationState,\r\n  newTotalItems: number\r\n): PaginationState => {\r\n  const totalPages = getTotalPages(newTotalItems, currentPagination.pageSize);\r\n  \r\n  return {\r\n    ...currentPagination,\r\n    totalItems: newTotalItems,\r\n    currentPage: Math.min(currentPagination.currentPage, Math.max(1, totalPages)),\r\n  };\r\n};\r\n\r\n// Reset pagination to first page\r\nexport const resetPagination = (pageSize: number): PaginationState => ({\r\n  currentPage: 1,\r\n  pageSize,\r\n  totalItems: 0,\r\n}); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}